---
title: JVM探秘（二）类文件结构--Class类文件的结构
date: 2018-5-27 22:06:25
categories: [jvm]
tags: [jvm]
---

本篇文章按照之前已经拟定好的顺序，首先来介绍类文件结构的第一部分：Class类文件的结构。
<!-- more -->

# 概述
"一次编写，到处运行"，这是java在刚刚诞生时提出的宣传口号，时至今日，JVM已经发展成了多种语言的运行平台，达成了两个方面：语言无关性和平台无关性，语言无关性是指：只要语言代码能被编译成存储字节码的Class文件，一样能够在jvm上运行，jvm不关心原代码是用什么编写的，平台无关性是指：同样的代码，在不同平台上的运行结果一致，其中Class文件的内容结构是构成这一切的基石。Class内容的来源可以有很多种，最多的就是源代码代码编译生成class文件，还有java的动态字节码技术也可以生成class。
# ClassFile的结构
Class文件是一组以8位字节为基础单位的二进制流，各个数据项严格按照规定顺序紧凑的排列在Class文件中，中间没有任何分隔符号，也没有空隙。如果有需要占用8位字节以上的空间的数据项，则会按照高位在前的方式分割成若干个8位字节进行存储。根据JVM规范的规定，Class文件采用一种类似于C语言结构的伪结构来存储数据，这种结构只有两种数据类型：无符号数和表，JVM解析所有的结构都会以这两种类型为基础。

1.无符号数：JVM中的基本数据类型，以u1,u2,u4,u8分别代表1个，2个，4个，8个字节的无符号数，一个字节是8位二进制数。无符号数可以描述数字，索引引用，数量值或者按照UTF-8编码的字符串值

2.表：由多个无符号数或者其他表作为数据项的复合数据类型，以_info结尾。整个Class文件本质上就是一张表,表中包含:magic,minor_version,major_version,constant_pool_count,constant_pool[cconstant_pool_count-1],assess_flags,this_class,super_class,interfaces_count,interfaces[interfaces_count],fields_count,fields[fields_count],methods_count,methods[methods_count],attributies_count,attributies[attributies_count]这些数据项，无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的计数器加上若干个连续的数据项的形式，下面将一一介绍。
## magic
magic的数据类型是u4,每个class文件的头4个字节成为magic,magic的唯一作用就是确定这个文件是否是一个能被jvm所接受的class文件，固定值：0xCAFEBABY,不会改变
## minor_version(父版本号),major_version(主版本号)
紧接着magic出现的4个字节存储的是class文件的版本号,第五和第六个字节是次版本号，第七和第八个字节是主版本号，这两个共同构成了class文件的版本号，jvm拒绝执行超过其版本号的class文件，即使文件格式完全符合其要求也不行。
## 常量池
紧接着主版本号之后的是常量池的入口，前两个字节表示常量池的大小，这个容量计数是从1而不是从0开始的，这样做是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量”的含义，这种情况可以把索引值置为0来表示。Class文件中只有常量池的容量计数是从1开始，其它的都是从0开始。
常量池中主要存放2大类常量，字面量和符号引用.
字面量：如文本字符串，声明为final的常量等。
符号引用：类和接口的全限定名，字段的名称和描述符，方法的名称和描述符。
Class文件中不会保存各个方法，字段的最终内存布局信息，当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建或者运行时解析，翻译到具体的内存地址之中。
常量池中每一项常量都是一个表，在jdk7之前共有11种结构各不相同的表结构，7之后为了支持动态语言调用，增加了CONSTANT_MethodHandle_info,CONSTANT_MethodType_info和CONSTANT_InvokeDynamic_info。
这14种表的共同点就是表开始的第一位是一个u1类型的标志位，代表当前这个常量表属于哪种类型。14种常量类型和标志位见下表所示。
