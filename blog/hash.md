---
title: java中hashCode与hash算法简介
date: 2018-10-20 20:46:25
categories: [java]
tags: [java,算法]
---

本文主要说明java中hashCode的计算方式以及hash算法，基于我在看jdk中HashMap中不明白的地方所做的解释

<!-- more -->
# 前言
好奇心是驱动人类进步的动力，我在看HashMap的源码的时候，put方法在查询key值得存储位置的时候，使用的是key的hash值去计算的，当时我就在想，一个key的hash值是如何保证均衡分布在各个存储桶里面的？带着这个好奇，我们今天就来探究下hash散列的计算方式及其原理。

# 基础知识
在开始之前，我们先来复习一下两个基本的东西：java中的位运算，散列码
## 位运算
大家在大学的时候应该都学过位运算符，这里就只列出来，加上一点说明
```java
<< : 左移运算符，num << 1,相当于num乘以2的一次方  低位补0
>> : 右移运算符，num >> 1,相当于num除以2的一次方  高位补0
>>> : 无符号右移，忽略符号位，空位都以0补齐
 % : 模运算 取余
^ :   位异或 第一个操作数的的第n位于第二个操作数的第n位相反，那么结果的第n为也为1，否则为0
 & : 与运算 第一个操作数的的第n位于第二个操作数的第n位如果都是1，那么结果的第n为也为1，否则为0
 | :  或运算 第一个操作数的的第n位于第二个操作数的第n位 只要有一个是1，那么结果的第n为也为1，否则为0
 ~ : 非运算 操作数的第n位为1，那么结果的第n位为0，反之，也就是取反运算（一元操作符：只操作一个数)
```
## 散列算法
又称哈希算法，杂凑算法，是一种从任意文件中创造小的数字「指纹」的方法。与指纹一样，散列算法就是一种以较短的信息来保证文件唯一性的标志，这种标志与文件的每一个字节都相关，而且难以找到逆向规律。因此，当原有文件发生改变时，其标志值也会发生改变，从而告诉文件使用者当前的文件已经不是你所需求的文件。
大家看一下Object中的hashCode方法就会发现，java中的hashCode方法是根据一定的规则，将与对象相关的一些信息（比如对象的地址，字段等）处理成一个int数值，这个值就称作散列码。从这里就可以看出，其hashCode的值只是和对象的内存地址有一定的关联，并不是返回的对象的内存地址

# Hash算法有什么特点？
一个优秀的 hash 算法，将能实现：

* 正向快速：给定明文和 hash 算法，在有限时间和有限资源内能计算出 hash 值。
* 逆向困难：给定（若干） hash 值，在有限时间内很难（基本不可能）逆推出明文。
* 输入敏感：原始输入信息修改一点信息，产生的 hash 值看起来应该都有很大不同。
* 冲突避免：很难找到两段内容不同的明文，使得它们的 hash 值一致（发生冲突）。即对于任意两个不同的数据块，其hash值相同的可能性极小；对于一个给定的数据块，找到和它hash值相同的数据块极为困难。

# String中的hashCode计算方式
```Java
public int hashCode() {
        int h = hash;
        if (h == 0 && value.length > 0) {
            char val[] = value;

            for (int i = 0; i < value.length; i++) {
                h = 31 * h + val[i];
            }
            hash = h;
        }
        return h;
    }
```
代码很简单，将字符串转换成字符数组，前一个字符的hash值x31+当前字符的unicode码，例如，字符串"abc",字符串中hash的初始值是0,a的unocide码是97,31x0+97，a的hashCode就是97,hash值也变成了97,b的计算方式就是97x31+98=3105,c的就是3105x31+99=96354,最终，“abc”的hashCode就是96354,不信的大家可以验证下。

# 为何很多hashCode方法都是使用的31
大家用eclipse生成hashCode方法的时候会发现,返回的hashCode是用31加上字段的hashCode码，为何是31呢，这个原因在《Effective Java》这本书里有说明：
```
之所以使用 31， 是因为他是一个奇素数。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算（低位补0）。使用素数的好处并不很明显，但是习惯上使用素数来计算散列结果。 31 有个很好的性能，即用移位和减法来代替乘法，可以得到更好的性能： 31 * i == (i << 5） - i， 现代的 VM 可以自动完成这种优化。这个公式可以很简单的推导出来。
```
这里可以看出，使用31还是为了性能。

# Hash在管理数据结构中的应用
在用到hash进行管理的数据结构中，对hash速度比较重视，对于碰撞检测不太看中，只要保证hash均匀分布就可以。比如hashmap，hash值（key）存在的目的是加速键值对的查找，key的作用是为了将元素适当地放在各个桶里，对于碰撞检测的要求没有那么高。换句话说，hash出来的key，只要保证value大致均匀的放在不同的桶里就可以了。但整个算法的set性能，直接与hash值产生的速度有关，所以这时候的hash值的产生速度就尤为重要.

# HashMap中的hash算法实现

我们知道，HashMap中计算key的hash值是为了key均匀分布，大家看一下下面这段代码
```Java
static final int hash(Object key) {
        int h;
        //计算hashCode，并无符号移动到低位
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```
这里可以看出，其key的hash值是取hashCode码与hashCode码无符号右移16位做异或运算，但是，为什么要右移16位呢，举个例子: 363771819^(363771819 >>> 16)
```
0001 0101 1010 1110 1011 0111 1010 1011(363771819)
0000 0000 0000 0000 0001 0101 1010 1110(5550) XOR
--------------------------------------- =
0001 0101 1010 1110 1010 0010 0000 0101(363766277)
```
这样做可以实现使高低位更加均匀地混到一起。
# 附录
下面给出在Java中几个常用的哈希码(hashCode)的算法。

1. Object类的hashCode. 返回对象的经过处理后的内存地址，由于每个对象的内存地址都不一样，所以哈希码也不一样。这个是native方法，取决于JVM的内部设计，一般是某种C地址的偏移。

2. String类的hashCode. 根据String类包含的字符串的内容，根据一种特殊算法返回哈希码，只要字符串的内容相同，返回的哈希码也相同。

3. Integer等包装类，返回的哈希码就是Integer对象里所包含的那个整数的数值，例如Integer i1=new Integer(100), i1.hashCode的值就是100 。由此可见，2个一样大小的Integer对象，返回的哈希码也一样。

4. int，char这样的基础类，它们不需要hashCode，如果需要存储时，将进行自动装箱操作，计算方法同上。
